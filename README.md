# ComputerNetwork_Project
计网项目

---

**说明**

- 使用类是因为翻qrcode的源代码发现也是用类 所以就抄了

- 掩码究竟有没有我没有测试 纯粹看到原版也有所以我就让ai加了

  ---

  二维码相关逻辑（myqr.py）

- 编码部分大致逻辑：
  - 生成空网格
  - 界定可放置数据模块的区域
  - rs
  - 测试最佳掩码并应用
  - 放置信息区（因为信息区有掩码序号所以得先测试掩码再放置信息区）

- 二维码大致设计为：

    1. 最外圈3模块大小的白边隔离

    2. 四个角的finder

       ​	<--    因为测过三个不行

    3. 左上角finder下面的信息区（36bit）

    4. 左上角finder右边的空白区

       ​	<--    因为强行适应2kb的bpf，继续往里加就不是整数了，所以流出来了，可以对外说是为了后续的插入更多信息（如原文件后缀等等）

       ​	<--    具体区域设置可以查看主目录下的test.png文件，白色区域为可写数据区

    5. 数据分为64块，每块36bytes，其中有8bytes冗余字节，理论可以允许4bytes的错误

- 解码部分大致逻辑：

    1. 高斯模糊预处理，ai说是能防止摩尔纹，但是我没具体测试，不过实际看下来是没什么大用（因为糊了就基本寄了）

    2. 二值化，用的是自适应模式，测试发现比直接写数值成功率高了很多倍（改之前基本读不出来），设置的参数（21,5）也是测过几遍得出的最佳数值

    3. 形态学操作，ai说是清理噪点，我没看懂，也没测试不用的情况

    4. 寻找定位点，用opencv的findContours找那种圈圈套圈圈的轮廓

    5. 矫正网格并采样网络，用四个finder透视变换来矫正，划分网格模块后，以每个模块中心50%的区域的平均值作为采样值
    
       ​	<--    矫正部分是测试过多次，透视变换最好用；采样没测过其他方法，ai给出第一版就是这个，没出过错就没动过
    
    6. 读取信息区
    
    7. 提取数据并反掩码
    
    8. rs解码，如果出现一块不成功rs，说明整帧二维码读取失败，可能得依靠全局的rs


---

  视频<=>文件逻辑

  - 文件->视频（encoder.py）
    1. 读取文件并进行分组，每组大小计算为$bpf=(qr.NSIZE - qr.NSYMB) * qr.BLOCK$，目前结果为2kb；其中最后一组会进行补足长度至bpf
    2. 全局rs，每200块原始数据生成$200\times0.15=30$​块

       ​	<--    这个数值其实设置的不合理，理论也应该类似上文中的每28生成8，但是懒得改了
    3. 生成二维码
    4. 合成视频，每个单帧默认重复4次，生成一个60fps的视频

       ​	<--    有两种方案：方案一是仅重复一次，在单帧之间插入2帧全白；方案二是单帧相互挨着，无全白，由于设备缺陷无法测试哪一种更好，目前是使用方案二

- 视频->文件（decoder.py）

  1. 读取文件并保存帧文件

     ​	<--    理论上测试阶段保存是好的，现在应该不要保存

  2. 每帧进行解码

     ​	<--    理论上测试阶段保存是好的，现在应该不要保存

  3. 全局rs

  4. 合成文件

---

##### 环境配置说明：

```powershell
python -m venv .venv
.\.venv\Scripts\activate
pip install -r requirements.txt
```

---

**运行说明**

!!如果无法运行，请查看main.py头部的说明!!

```powershell
python src/main.py -h	# 查看帮助
python src/main.py e 	# 编码文件
python src/main.py d	# 解码文件
```

